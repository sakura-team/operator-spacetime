<!--Code started by Michael Ortega for the LIG-->
<!--Started on: April 19th, 2017-->

<!DOCTYPE html>

<html style="height:100%;">
    <head>
        <meta charset="UTF-8" />
        <script src="/js/sakura-common.js"></script>
        <script src="/js/sakura-operator.js"></script>
        
        <!-- operator-specific includes ... -->
        <script src="/js/jquery-2.2.4.min.js"></script>
        
        <!-- ... done. -->
    </head>
    <body style="height:100%;">
        <input type="file" id="files" name="files" onchange="gps_read(event)" multiple />
        <canvas id="container" style="height:100%; width: 100%;">
            <script src="libs/shaders.js"></script>
            <script src="libs/matrix.js"></script>
            <script src="libs/camera.js"></script>
            <script src="libs/gps.js"></script>
            <script type="text/javascript">
                ///////////////////////////////////////////////////////////////////
                // GLOBALS
                var gl              = null;     //main gl context
                var floor_p         = null;     //vertices
                var floor_p_buf     = null;
                var floor_p_loc     = null;
                var floor_n         = null;     //normals
                var floor_n_buf     = null;
                var floor_n_loc     = null;
                var canvas          = document.getElementById("container");
                var tempx           = 0;
                var camera          = new Camera(pos = [0, 0, 10]);
                var mode            = "idle";
                var mouse           = {x: 0,y: 0,dx: 0,dy:  0}; //posx, poy, dx, dy
                var paths           = [];
                var rot_angle       = [0, 0];
                
                ///////////////////////////////////////////////////////////////////
                // INIT FUNCS
                function init_webgL(_canvas) { 
                    
                    _canvas.width = _canvas.clientWidth;
                    _canvas.height = _canvas.clientHeight;
                    
                    try {
                        // Essaye de récupérer le contexte standard. En cas d'échec, il teste l'appel experimental
                        var _gl = _canvas.getContext("webgl") || _canvas.getContext("experimental-webgl");
                    }
                    catch(e) {
                        console.log(e);
                        return null;
                    }
                    
                    // Si le contexte GL n'est pas récupéré, on l'indique à l'utilisateur.
                    if (!_gl) {
                        alert("Impossible d'initialiser le WebGL. Il est possible que votre navigateur ne supporte pas cette fonctionnalité.");
                        return null;
                    }
                    console.log('WebGL initialized !!');
                    
                    
                    canvas.onmousedown = function (event) {
                        mode = "rotation"
                        mouse.x = event.clientX;
                        mouse.y = event.clientY;
                        requestAnimationFrame(display);
                    };
                    
                    canvas.onmouseup = function () {
                        mode = "idle"
                        requestAnimationFrame(display);
                    };
                    
                    canvas.onmousemove = function (event) {
                        if (mode == "rotation") {
                            mouse.dx = event.clientX - mouse.x;
                            mouse.dy = event.clientY - mouse.y;
                            mouse.x = event.clientX;
                            mouse.y = event.clientY;
                            requestAnimationFrame(display);
                        }
                    }
                    
                    camera.projection = m_perspective(45, _gl.drawingBufferWidth/_gl.drawingBufferHeight, 0.01, 1000);
                    return _gl;
                }
                
                
                ///////////////////////////////////////////////////////////////////
                // COMPUTATION FUNCS
                
                
                function floor_pos() {
                    return [
                    // Front face
                    -1.0,  0.0,  1.0,
                    1.0, 0.0,  1.0,
                    1.0,  0.0,  -1.0,
                    
                    -1.0, 0.0,  1.0,
                    1.0,  0.0,  -1.0,
                    -1.0,  0.0,  -1.0
                     
                    /*// Right face
                     1.0,  1.0, -1.0,
                     1.0, -1.0, -1.0,
                     
                    // Back face
                    -1.0,  1.0, -1.0,
                    -1.0, -1.0, -1.0,
                     
                    // left face
                    -1.0,  1.0, 1.0,
                    -1.0, -1.0, 1.0
                    */
                  ];
                }
                
                function floor_nor() {
                    return [
                    // Front face
                    0.0, 1.0,  0.0,
                    0.0, 1.0,  0.0,
                    0.0, 1.0,  0.0,
                    0.0, 1.0,  0.0,
                    0.0, 1.0,  0.0,
                    0.0, 1.0,  0.0
                    
                    /*
                    // Right face
                    1.0, 0.0,  0.0,
                    1.0, 0.0,  0.0,
                    
                    // Back face
                    0.0, 0.0,  -1.0,
                    0.0, 0.0,  -1.0,
                    
                    // Left face
                    -1.0, 0.0,  0.0,
                    -1.0, 0.0,  0.0,
                    */
                    ]
                }
                
                
                ///////////////////////////////////////////////////////////////////
                // DISPLAY FUNCS
                
                function display() {
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                    
                    
                    /////////////////////////////////////////////////
                    // FLOOR
                    gl.useProgram(floor_sh);
                    gl.enableVertexAttribArray(floor_p_loc);
                    gl.bindBuffer(gl.ARRAY_BUFFER, floor_p_buf);
                    gl.vertexAttribPointer(floor_p_loc, 3, gl.FLOAT, false, 0, 0);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(floor_p), gl.DYNAMIC_DRAW);
                    
                    
                    gl.enableVertexAttribArray(floor_n_loc);
                    gl.bindBuffer(gl.ARRAY_BUFFER, floor_n_buf);
                    gl.vertexAttribPointer(floor_n_loc, 3, gl.FLOAT, false, 0, 0);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(floor_n), gl.DYNAMIC_DRAW);
                    
                    rot_angle[0] += 2*Math.PI*mouse.dx/parseFloat(canvas.width);
                    rot_angle[1] += 2*Math.PI*mouse.dy/parseFloat(canvas.height);
                    
                    var qx = m_quaternion(rot_angle[0], [0, 1, 0]);
                    var qy = m_quaternion(rot_angle[1], [1, 0, 0]);
                    
                    camera.pos = rotatePointWithPivot(camera.init_pos, qx, camera.vp);
                    camera.pos = rotatePointWithPivot(camera.pos, qy, camera.vp);
                    
                    up_p = [    camera.init_pos[0] + camera.init_up[0],
                                camera.init_pos[1] + camera.init_up[1],
                                camera.init_pos[2] + camera.init_up[2]  ];
                                
                    up_p = rotatePointWithPivot(up_p, qx, camera.vp);
                    up_p = rotatePointWithPivot(up_p, qy, camera.vp);
                    
                    camera.up = m_vector(camera.pos, up_p)
                    
                    m_setMatrixUniforms(floor_sh,
                                        camera.projection,
                                        m_lookAt(camera.pos, [0,0,0], camera.up)  );
                    
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    
                    
                    /////////////////////////////////////////////////
                    // PATHS
                    gl.useProgram(paths_sh);
                    
                    
                }
                
                ///////////////////////////////////////////////////////////////////
                // MAIN
                
                gl                      = init_webgL(canvas);
                
                // FLOOR SHADER
                floor_sh                = init_shader(gl, floor_fragment_source, floor_vertex_source);
                
                floor_n_loc            = gl.getAttribLocation(floor_sh, "normal");
                gl.enableVertexAttribArray(floor_n_loc);
                floor_n                = floor_nor();
                floor_n_buf            = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, floor_n_buf);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(floor_n), gl.DYNAMIC_DRAW);
                
                floor_p_loc   = gl.getAttribLocation(floor_sh, "position");
                gl.enableVertexAttribArray(floor_p_loc);
                floor_p                = floor_pos();
                floor_p_buf            = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, floor_p_buf);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(floor_p), gl.DYNAMIC_DRAW);
                
                
                // PATHS SHADER
                paths_sh                = init_shader(gl, paths_fragment_source, paths_vertex_source)
                
                
                if (gl) {
                    gl.clearColor(0.5, 0.5, 1.0, 1.0);                      // Met la couleur d'effacement au noir et complétement opaque
                    gl.enable(gl.DEPTH_TEST);                               // Active le test de profondeur
                    gl.depthFunc(gl.LEQUAL);                                // Les objets proches cachent les objets lointains
                    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);      // Efface les couleurs et le buffer de profondeur.
                    
                    requestAnimationFrame(display);
                }
            </script>
        </canvas>
    </body>
</html>

